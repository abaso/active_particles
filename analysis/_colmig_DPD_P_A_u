#! /home/yketa/miniconda3/bin/python3.6

import os
import sys

sys.path.append('/home/yketa')
from exponents import float_to_letters
sys.path.append('/home/yketa/hoomd/colmig_DPD_P_A/data')
from readdat import *

import numpy as np
import math

import gsd
import gsd.hoomd
import gsd.pygsd

import pickle

time = int(eval(os.environ['TIME'])) if 'TIME' in os.environ else -1 # inital time for the displacement
dt = int(eval(os.environ['DT'])) if 'DT' in os.environ else -1 # time interval for the displacement

frame_ver = int(eval(os.environ['FRAME_VERTICAL_SIZE'])) if 'FRAME_VERTICAL_SIZE' in os.environ else 12 # vertical size of the frame (in inches)
frame_hor = int(eval(os.environ['FRAME_HORIZONTAL_SIZE'])) if 'FRAME_HORIZONTAL_SIZE' in os.environ else 12 # vertical size of the frame (in inches)
frame_def = int(eval(os.environ['FRAME_DEFINITION'])) if 'FRAME_DEFINITION' in os.environ else 80 # definition of the frame (in dots per inches (dpi))

width = float(eval(os.environ['ARROW_WIDTH'])) if 'ARROW_WIDTH' in os.environ else 1e-3 # width of the arrows
head_width = float(eval(os.environ['HEAD_WIDTH']))*width if 'HEAD_WIDTH' in os.environ else 3e2*width # width of the arrows' head (input in ratio of the width of the arrows)
head_length = float(eval(os.environ['HEAD_LENGTH']))*head_width if 'HEAD_LENGTH' in os.environ else 1.5*head_width # width of the arrows' head (input in ratio of the width of the arrows' head)

data_dir = os.environ['DATA_DIRECTORY'] if 'DATA_DIRECTORY' in os.environ else os.getcwd() # data directory

wrap_file_name = os.environ['WRAPPED_FILE'] if 'WRAPPED_FILE' in os.environ else data_dir + '/trajectory.gsd' # wrapped trajectory file (.gsd)
unwrap_file_name = os.environ['UNWRAPPED_FILE'] if 'UNWRAPPED_FILE' in os.environ else data_dir + '/trajectory.dat' # unwrapped trajectory file (binary)
param_file = os.environ['PARAMETERS_FILE'] if 'PARAMETERS_FILE' in os.environ else data_dir + '/param.pickle' # parameters file

file = open(param_file, 'rb')
N, a, pdi, N_sizes, density, box_size, kT, mu, k, vzero, dr, damp_bro, shear_rate, time_step, N_steps, period_dump, prep_steps = pickle.load(file)
file.close()

Nentries = N_steps//period_dump # number of time snapshots in binary trajectory file
time = int(Nentries/2) if time < 0 else time
dt = Nentries - time + dt if dt < 0 else dt

prep_frames = math.ceil(prep_steps/period_dump) # number of preparation frames

# POSITIONS AND DISPLACEMENTS

with gsd.pygsd.GSDFile(open(wrap_file_name, 'rb')) as wrap_file, open(unwrap_file_name, 'rb') as unwrap_file:
	w_traj = gsd.hoomd.HOOMDTrajectory(wrap_file);
	positions = w_traj[int(prep_frames + time)].particles.position[:, :2] # positions at time time
	displacements = getarray(unwrap_file, N, time + dt) - getarray(unwrap_file, N, time) # displacements between times time and time + dt

# DRAWING

import matplotlib as mpl
if not('SHOW' in os.environ and eval(os.environ['SHOW'])):
	mpl.use('Agg')
import matplotlib.pyplot as plt

fig, ax = plt.subplots()
fig.set_size_inches(frame_hor, frame_ver)

for particle in range(N): # for every particle

	disp_n = np.sqrt(np.sum(displacements[particle]**2)) # distance of the displacement
	if disp_n > 0:
		ax.arrow(positions[particle, 0], positions[particle, 1], displacements[particle, 0], displacements[particle, 1], width=disp_n*width, head_width=disp_n*head_width, head_length=disp_n*head_length, head_starts_at_zero=True, color='blue')

ax.set_xlim([-1.1*box_size/2, 1.1*box_size/2])
ax.set_ylim([-1.1*box_size/2, 1.1*box_size/2])
ax.set_aspect('equal')

ax.set_xlabel(r'$x$')
ax.set_ylabel(r'$y$')

ax.set_title(r'$\phi = $' + str(density) + r'$, \tilde{v} = $' + "%e" % vzero + r'$, \tilde{\nu}_r = $' + "%e" % dr + '\n' + r'$t_{init} = $' + str(time_step*period_dump*time) + r'$, \Delta t = $' + str(time_step*period_dump*dt))

# SAVING

if 'SAVE' in os.environ and eval(os.environ['SAVE']):
	fname = 'u_D' + float_to_letters(density) + '_V' + float_to_letters(vzero) + '_R' + float_to_letters(dr) + '_N' + float_to_letters(N) + '_T' + float_to_letters(time) + '_I' + float_to_letters(dt) + '.eps' # filename
	plt.savefig(data_dir + '/' + fname) # saving the figure

# DISPLAYING

if 'SHOW' in os.environ and eval(os.environ['SHOW']):
	plt.show()
