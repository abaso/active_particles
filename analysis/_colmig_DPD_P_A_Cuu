#! /home/yketa/miniconda3/bin/python3.6

import os
import sys

import math

import gsd
import gsd.hoomd
import gsd.pygsd

import numpy as np

import pickle

sys.path.append('/home/yketa')
from exponents import float_to_letters
sys.path.append('/home/yketa/hoomd/colmig_DPD_P_A/data')
from readdat import *

from collections import OrderedDict

data_dir = os.environ['DATA_DIRECTORY'] if 'DATA_DIRECTORY' in os.environ else os.getcwd() # data directory

wrap_file_name = os.environ['WRAPPED_FILE'] if 'WRAPPED_FILE' in os.environ else data_dir + '/trajectory.gsd' # wrapped trajectory file (.gsd)
unwrap_file_name = os.environ['UNWRAPPED_FILE'] if 'UNWRAPPED_FILE' in os.environ else data_dir + '/trajectory.dat' # unwrapped trajectory file (binary)
parameters_file = os.environ['PARAMETERS_FILE'] if 'PARAMETERS_FILE' in os.environ else data_dir + '/param.pickle' # parameters file

dis_time = int(eval(os.environ['TIME'])) if 'TIME' in os.environ else -1 # time interval for the displacement

init_frame = int(eval(os.environ['INITIAL_FRAME'])) if 'INITIAL_FRAME' in os.environ else -1 # initial time for the calculation of the displacement correlation
int_max = int(eval(os.environ['INTERVAL_MAXIMUM'])) if 'INTERVAL_MAXIMUM' in os.environ else 1 # maximum number of intervals taken for the calculation of the displacement correlation

with open(parameters_file, 'rb') as param_file:
	N, a, pdi, N_sizes, density, box_size, kT, mu, k, vzero, dr, damp_bro, shear_rate, time_step, N_steps, period_dump, prep_steps = pickle.load(param_file)

prep_frames = math.ceil(prep_steps/period_dump) # number of preparation frames

Ncases = int(eval(os.environ['N_CASES'])) if 'N_CASES' in os.environ else int(np.sqrt(N)) + (1 - int(np.sqrt(N))%2) # number of cases in each direction to compute the velocity grid

Nentries = N_steps//period_dump # number of time snapshots in velocity and position files
init_frame = int(Nentries/2) if init_frame < 0 else init_frame # initial frame
Nframes = Nentries - init_frame # number of frames available for the calculation

dis_time = Nframes + dis_time if dis_time <= 0 else dis_time # length of the interval of time for which the correlation displacement is calculated

times = np.array(list(OrderedDict.fromkeys(map(lambda x: int(x), np.linspace(init_frame, Nentries - dis_time - 1, int_max))))) # frames at which to calculate the correlation displacement

def displacement_grid(Ncases, N, L, time, dis_time, prep_frames, wrap_file, unwrap_file):
	# This function associates a Ncases x Ncases grid to the box and calculates the average
	# displacement over time dis_time from time time in every cases.

	dL = L/Ncases

	w_traj = gsd.hoomd.HOOMDTrajectory(wrap_file);
	pos = w_traj[int(prep_frames + time + (dis_time if 'ENDPOINT' in os.environ and eval(os.environ['ENDPOINT']) else 0))].particles.position[:, :2] # position at time time (with boundary conditions)
	index = np.array((pos + L/2)//dL, dtype=int) # 2D index of every particles

	pos0 = getarray(unwrap_file, N, time) # positions at time time (without periodic boundary conditions)
	pos1 = getarray(unwrap_file, N, time + dis_time) # position at time time + dis_time (without periodic boundary conditions)
	displacement = pos1 - pos0 # displacements of the particles between time and time + dis_time
	displacement_wd = (pos1 - np.mean(pos1, axis=0)) - (pos0 - np.mean(pos0, axis=0))  # displacements of the particles between time and time + dis_time without centre of mass drift

	ugrid_dic, wgrid_dic = {}, {}
	for particle in range(N):
		if (index[particle] < Ncases).all():
			ugrid_dic[tuple(index[particle])] = ugrid_dic[tuple(index[particle])] + [displacement[particle]] if tuple(index[particle]) in ugrid_dic else [displacement[particle]]
			wgrid_dic[tuple(index[particle])] = wgrid_dic[tuple(index[particle])] + [displacement_wd[particle]] if tuple(index[particle]) in wgrid_dic else [displacement_wd[particle]]

	ugrid, wgrid = np.zeros((Ncases, Ncases, 2)), np.zeros((Ncases, Ncases, 2))
	for index in ugrid_dic:
		ugrid[index] = np.mean(ugrid_dic[index], axis=0)
		wgrid[index] = np.mean(wgrid_dic[index], axis=0)

	ngrid = (ugrid != 0).any(axis=-1)*1 # density grid
	ngridr = np.reshape(ngrid, ngrid.shape + (1,))
	dgrid = np.sqrt(np.sum(ugrid**2, axis=-1)) # displacement norm grid
	dgridr = np.reshape(dgrid, dgrid.shape + (1,))

	egrid = np.divide(ugrid, dgridr, out=np.zeros(ugrid.shape), where=dgridr!=0) # displacement direction

	return np.concatenate((ngridr, dgridr), axis=-1), ugrid, wgrid, egrid # for reasons of dimensions, ngrid and dgrid have to be passed together

def corField(field):
	# Return 2D correlation of a scalar field.

	FFT = np.fft.fft2(field)
	C = np.real(np.fft.ifft2(np.conj(FFT)*FFT))
	Norm = np.sum(field**2)

	return C, Norm

def cor2DField(field):
	# Returns 2D correlation of a vector field.

	xfield = field[:, :, 0]
	xC, xNorm = corField(xfield)

	yfield = field[:, :, 1]
	yC, yNorm = corField(yfield)

	C = xC + yC # correlation
	xCL, yCL = xC[0, 1], yC[1, 0] # longitudinal correlation
	xCT, yCT = xC[1, 0], yC[0, 1] # tranversal correlation
	Norm = xNorm + yNorm

	return C, xCL, yCL, xCT, yCT, Norm

with gsd.pygsd.GSDFile(open(wrap_file_name, 'rb')) as wrap_file, open(unwrap_file_name, 'rb') as unwrap_file:
	NDgrid, Ugrid, Wgrid, Egrid = tuple(np.transpose(list(map(lambda time: displacement_grid(Ncases, N, box_size, time, dis_time, prep_frames, wrap_file, unwrap_file), times)), (1, 0, 2, 3, 4)))
Ngrid = NDgrid[:, :, :, 0]
Dgrid = NDgrid[:, :, :, 1]

Cnn2D, Cdd2D = tuple(list(map(lambda Grid: (lambda C, Norm: C/Norm)(*tuple(np.sum(list(map(corField, Grid)), axis=0))), [Ngrid, Dgrid]))) # scalar field correlations

(Cuu2D, CuuL, CuuT), (Cww2D, CwwL, CwwT), (Cee2D, CeeL, CeeT) = list(map(lambda Grid: (lambda C, xCL, yCL, xCT, yCT, Norm: (C/Norm, (xCL/Cnn2D[0, 1] + yCL/Cnn2D[1, 0])/(2*Norm), (xCT/Cnn2D[1, 0] + yCT/Cnn2D[0, 1])/(2*Norm)))(*tuple(np.sum(list(map(cor2DField, Grid)), axis=0))), [Ugrid, Wgrid, Egrid])) # vector field correlations

def dicto1D(C1D_dic, Ncases, L):
	return np.array(list(map(lambda dist: [np.sqrt(dist)*(L/Ncases), np.mean(C1D_dic[dist])], sorted(C1D_dic))))

def C2Dto1D(C2D, Ncases, L, Cnn, cor=True):
	# Returns 1D correlation from 2D.

	C1D_dic, C1Dcor_dic = {}, {}
	for i in range(Ncases):
		for j in range(Ncases):
			if (i**2 + j**2) <= (Ncases/2)**2:
				C1D_dic[int(i**2 + j**2)] = C1D_dic[int(i**2 + j**2)] + [C2D[i, j]] if int(i**2 + j**2) in C1D_dic else [C2D[i, j]]
				if cor:
					C1Dcor_dic[int(i**2 + j**2)] = C1Dcor_dic[int(i**2 + j**2)] + [C2D[i, j]/Cnn[i, j]] if int(i**2 + j**2) in C1Dcor_dic else [C2D[i, j]/Cnn[i, j]]

	if cor:
		C1D, C1Dcor = tuple(list(map(lambda dic: dicto1D(dic, Ncases, L), [C1D_dic, C1Dcor_dic])))
		return C1D, C1Dcor
	else:
		C1D = dicto1D(C1D_dic, Ncases, L)
		return C1D

Cnn1D = C2Dto1D(Cnn2D, Ncases, box_size, Cnn2D, cor=False)

(Cuu1D, Cuu1Dcor), (Cww1D, Cww1Dcor), (Cdd1D, Cdd1Dcor), (Cee1D, Cee1Dcor) = list(map(lambda C2D: C2Dto1D(C2D, Ncases, box_size, Cnn2D), [Cuu2D, Cww2D, Cdd2D, Cee2D]))

# SAVING

filename = lambda var: data_dir + str('/' + var + ('b' if not('ENDPOINT' in os.environ and eval(os.environ['ENDPOINT'])) else '') + '_D%s_V%s_R%s_N%s_I%s_T%s_M%s_C%s.pickle' % tuple(map(float_to_letters, [density, vzero, dr, N, init_frame, dis_time, int_max, Ncases]))) # filename

with open(filename('Cnn'), 'wb') as Cnn_dump_file, open(filename('Cuu'), 'wb') as Cuu_dump_file, open(filename('Cww'), 'wb') as Cww_dump_file, open(filename('Cdd'), 'wb') as Cdd_dump_file, open(filename('Cee'), 'wb') as Cee_dump_file:
	pickle.dump([Cnn2D, Cnn1D], Cnn_dump_file)
	pickle.dump([Cuu2D, Cuu1D, Cuu1Dcor, CuuL, CuuT], Cuu_dump_file)
	pickle.dump([Cww2D, Cww1D, Cww1Dcor, CwwL, CwwT], Cww_dump_file)
	pickle.dump([Cdd2D, Cdd1D, Cdd1Dcor], Cdd_dump_file)
	pickle.dump([Cee2D, Cee1D, Cee1Dcor, CeeL, CeeT], Cee_dump_file)

# PLOT

if 'SHOW' in os.environ and eval(os.environ['SHOW']):

	import matplotlib as mpl
	import matplotlib.pyplot as plt
	import matplotlib.colors as colors
	import matplotlib.cm as cmx
	from mpl_toolkits.axes_grid1 import make_axes_locatable
	from matplotlib.gridspec import GridSpec
	cmap = plt.cm.jet

	# plot parameters

	Cuu_min = float(eval(os.environ['CUU_MIN'])) if 'CUU_MIN' in os.environ else 1e-3
	Cuu_max = float(eval(os.environ['CUU_MAX'])) if 'CUU_MAX' in os.environ else 1

	Cww_min = float(eval(os.environ['CWW_MIN'])) if 'CWW_MIN' in os.environ else 1e-3
	Cww_max = float(eval(os.environ['CWW_MAX'])) if 'CWW_MAX' in os.environ else 1	

	Cdd_min = float(eval(os.environ['CDD_MIN'])) if 'CDD_MIN' in os.environ else 1e-1
	Cdd_max = float(eval(os.environ['CDD_MAX'])) if 'CDD_MAX' in os.environ else 2

	Cee_min = float(eval(os.environ['CEE_MIN'])) if 'CEE_MIN' in os.environ else 1e-3
	Cee_max = float(eval(os.environ['CEE_MAX'])) if 'CEE_MAX' in os.environ else 1

	r_min = float(eval(os.environ['R_MIN'])) if 'R_MIN' in os.environ else 1
	r_max = float(eval(os.environ['R_MAX'])) if 'R_MAX' in os.environ else 20

	plot_axis = os.environ['AXIS'] if 'AXIS' in os.environ else 'LOGLOG'
	fplot = lambda ax: ax.loglog if plot_axis == 'LOGLOG' else ax.semilogy if plot_axis == 'LINLOG' else ax.semilogx if plot_axis == 'LOGLIN' else ax.plot

	def plot_correlation(C, C2D, C1D, C1Dcor, C_min, C_max, **directional_correlations):

		fig, axs = plt.subplots(2, 2)

		fig.set_size_inches(16, 16)
		fig.subplots_adjust(wspace=0.3)
		fig.subplots_adjust(hspace=0.3)

		fig.suptitle(r'$N=%.2e, \phi=%1.2f, \tilde{v}=%.2e, \tilde{\nu}_r=%.2e$' % (N, density, vzero, dr) + '\n' + r'$S_{init}=%.2e, \Delta t=%.2e, S_{max}=%.2e, N_{cases}=%.2e$' % (init_frame, dis_time*period_dump*time_step, int_max, Ncases))

		# Cuu2D

		Cmin = np.min(C2D)
		Cmax = np.max(C2D)

		CvNorm = colors.Normalize(vmin=Cmin, vmax=Cmax)
		CscalarMap = cmx.ScalarMappable(norm=CvNorm, cmap=cmap) 

		r_max_cases = int(r_max*(box_size/Ncases))
		C2D_display = np.roll(np.roll(C2D, int(Ncases/2), axis=0), int(Ncases/2), axis=1)[int(Ncases/2) - r_max_cases:int(Ncases/2) + r_max_cases + 1, int(Ncases/2) - r_max_cases:int(Ncases/2) + r_max_cases + 1]

		axs[0, 0].imshow(C2D_display, cmap=cmap, norm=CvNorm, extent=[-r_max, r_max, -r_max, r_max])

		axs[0, 0].set_xlabel(r'$x$')
		axs[0, 0].set_ylabel(r'$y$')
		axs[0, 0].set_title('2D ' + r'$%s$' % C + ' ' + (r'$(%s^T/%s^L(\frac{r}{a} = %.3e) = %.3e)$' % (C, C, (box_size/Ncases)/a, directional_correlations['CT']/directional_correlations['CL']) if 'CL' in directional_correlations and 'CT' in directional_correlations else ''))

		divider = make_axes_locatable(axs[0, 0])
		cax = divider.append_axes("right", size="5%", pad=0.05)
		cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=CvNorm, orientation='vertical')
		cb.set_label(r'$%s$' % C, labelpad=20, rotation=270)

		# Cuu1D shifted

		fplot(axs[1, 0])(C1D[1:, 0], C1D[1:, 1]/Cnn1D[-1, 1])

		axs[1, 0].set_xlabel(r'$r$')
		axs[1, 0].set_ylabel(r'$%s$' % C + r'$/C_{\rho\rho}(r=r_{max})$')
		axs[1, 0].set_title('radial ' + r'$%s$' % C + r'$/C_{\rho\rho}(r=r_{max})$' + ' ' + r'$(C_{\rho\rho}(r=r_{max}) = %.3e)$' % Cnn1D[-1, 1])

		axs[1, 0].set_xlim(r_min, r_max)
		axs[1, 0].set_ylim(C_min, C_max)

		# Cnn1D and Cuu1D

		axs[0, 1].set_title('radial ' + r'$C_{\rho\rho}$' + ' and ' + r'$%s$' % C)
		axs[0, 1].set_xlabel(r'$r$')
		axs[0, 1].set_xlim(r_min, r_max)

		axs[0, 1].plot(Cnn1D[1:, 0], Cnn1D[1:, 1], color='#1f77b4')
		axs[0, 1].set_ylabel(r'$C_{\rho\rho}$', color='#1f77b4')
		axs[0, 1].tick_params('y', colors='#1f77b4')

		ax_right = axs[0, 1].twinx()
		ax_right.semilogy(C1D[1:, 0], C1D[1:, 1], color='#ff7f0e')
		ax_right.set_ylabel(r'$%s$' % C, color='#ff7f0e', rotation=270, labelpad=10)
		ax_right.tick_params('y', colors='#ff7f0e')
		ax_right.set_ylim(C_min*Cnn1D[-1, 1], C_max*Cnn1D[-1, 1])

		# Cuu1D/Cnn

		fplot(axs[1, 1])(C1Dcor[1:, 0], C1Dcor[1:, 1])

		axs[1, 1].set_xlabel(r'$r$')
		axs[1, 1].set_ylabel(r'$%s$' % C + r'$/C_{\rho\rho}$')
		axs[1, 1].set_title('radial ' + r'$%s$' % C + r'$/C_{\rho\rho}$')

		axs[1, 1].set_xlim(r_min, r_max)
		axs[1, 1].set_ylim(C_min, C_max)

		return fig

	fig0 = plot_correlation('C_{uu}', Cuu2D, Cuu1D, Cuu1Dcor, Cuu_min, Cuu_max, CL=CuuL, CT=CuuT)
	fig1 = plot_correlation('C_{\delta u \delta u}', Cww2D, Cww1D, Cww1Dcor, Cww_min, Cww_max, CL=CwwL, CT=CwwT)
	fig2 = plot_correlation('C_{|u||u|}', Cdd2D, Cdd1D, Cdd1Dcor, Cdd_min, Cdd_max)
	fig3 = plot_correlation('C_{\hat{u}\hat{u}}', Cee2D, Cee1D, Cee1Dcor, Cee_min, Cee_max, CL=CeeL, CT=CeeT)

	plt.show()
