#! /home/yketa/miniconda3/bin/python3.6

import os
import sys

import numpy as np

import pickle

sys.path.append('/home/yketa')
from exponents import float_to_letters

data_dir = os.environ['DATA_DIRECTORY'] if 'DATA_DIRECTORY' in os.environ else os.getcwd() # data directory
parameters_file = os.environ['PARAMETERS_FILE'] if 'PARAMETERS_FILE' in os.environ else data_dir + '/param.pickle' # parameters file

dis_time = int(eval(os.environ['TIME'])) if 'TIME' in os.environ else -1 # time interval for the displacement

init_frame = int(eval(os.environ['INITIAL_FRAME'])) if 'INITIAL_FRAME' in os.environ else -1 # initial time for the calculation of the displacement correlation
int_max = int(eval(os.environ['INTERVAL_MAXIMUM'])) if 'INTERVAL_MAXIMUM' in os.environ else 1 # maximum number of intervals taken for the calculation of the displacement correlation

r_max = float(eval(os.environ['R_MAX'])) if 'R_MAX' in os.environ else 20 # half size of the box showed for 2D correlation

with open(parameters_file, 'rb') as param_file:
	N, a, pdi, N_sizes, density, box_size, kT, mu, k, vzero, dr, damp_bro, shear_rate, time_step, N_steps, period_dump, prep_steps = pickle.load(param_file)

r_cut = a*float(eval(os.environ['R_CUT'])) if 'R_CUT' in os.environ else a*2 # cutoff radius for coarse graining function
sigma = float(eval(os.environ['SIGMA'])) if 'SIGMA' in os.environ else r_cut # length scale of the spatial extent of the coarse graining function

r_max = box_size/2 if r_max < 0 else r_max

Ncases = int(eval(os.environ['N_CASES'])) if 'N_CASES' in os.environ else int(np.sqrt(N)) + (1 - int(np.sqrt(N))%2) # number of cases in each direction to compute the velocity grid

Nentries = N_steps//period_dump # number of time snapshots in velocity and position files
init_frame = int(Nentries/2) if init_frame < 0 else init_frame # initial frame
Nframes = Nentries - init_frame # number of frames available for the calculation

dis_time = Nframes + dis_time if dis_time <= 0 else dis_time # length of the interval of time for which the correlation displacement is calculated

# DATA

filename = lambda var: data_dir + str('/' + var + ('b' if not('ENDPOINT' in os.environ and eval(os.environ['ENDPOINT'])) else '') + '_D%s_V%s_R%s_N%s_I%s_T%s_M%s_C%s_RCUT%s_SIGM%s' % tuple(map(float_to_letters, [density, vzero, dr, N, init_frame, dis_time, int_max, Ncases, r_cut, sigma]))) # filename

with open(filename('Css') + '.pickle', 'rb') as Css_dump_file:
	Sgrid, Css2D = pickle.load(Css_dump_file)

# PLOT

import matplotlib as mpl
if not('SHOW' in os.environ and eval(os.environ['SHOW'])):
	mpl.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.colors as colors
import matplotlib.cm as cmx
from mpl_toolkits.axes_grid1 import make_axes_locatable
from matplotlib.gridspec import GridSpec
cmap = plt.cm.jet

fig, ax = plt.subplots(1, 2)

fig.set_size_inches(16, 16)
fig.subplots_adjust(wspace=0.4)
fig.subplots_adjust(hspace=0.3)

fig.suptitle(r'$N=%.2e, \phi=%1.2f, \tilde{v}=%.2e, \tilde{\nu}_r=%.2e$' % (N, density, vzero, dr) + '\n' + r'$S_{init}=%.2e, \Delta t=%.2e, S_{max}=%.2e, N_{cases}=%.2e, r_{cut}=%.2e, \sigma=%.2e$' % (init_frame, dis_time*period_dump*time_step, int_max, Ncases, r_cut, sigma))

# strain

S = '\epsilon_{xy}'
S2D = Sgrid[0]

Smin = -2*np.std(S2D)
Smax = 2*np.std(S2D)

SvNorm = colors.Normalize(vmin=Smin, vmax=Smax)
SscalarMap = cmx.ScalarMappable(norm=SvNorm, cmap=cmap)

ax[0].imshow(S2D, cmap=cmap, norm=SvNorm, extent=[-box_size/2, box_size/2, -box_size/2, box_size/2])

ax[0].set_xlabel(r'$x$')
ax[0].set_ylabel(r'$y$')
ax[0].set_title('2D ' + r'$%s$' % S)

divider0 = make_axes_locatable(ax[0])
cax0 = divider0.append_axes("right", size="5%", pad=0.05)
cb0 = mpl.colorbar.ColorbarBase(cax0, cmap=cmap, norm=SvNorm, orientation='vertical')
cb0.set_label(r'$%s$' % S, labelpad=20, rotation=270)

# Css2D

C = 'C_{\epsilon_{xy}\epsilon_{xy}}'

Cmin = np.min(Css2D)
Cmax = np.max(Css2D)

CvNorm = colors.Normalize(vmin=Cmin, vmax=Cmax)
CscalarMap = cmx.ScalarMappable(norm=CvNorm, cmap=cmap)

r_max_cases = int(r_max*(Ncases/box_size))
C2D_display = np.roll(np.roll(Css2D, int(Ncases/2), axis=0), int(Ncases/2), axis=1)[int(Ncases/2) - r_max_cases:int(Ncases/2) + r_max_cases + 1, int(Ncases/2) - r_max_cases:int(Ncases/2) + r_max_cases + 1]

ax[1].imshow(C2D_display, cmap=cmap, norm=CvNorm, extent=[-r_max, r_max, -r_max, r_max])

ax[1].set_xlabel(r'$x$')
ax[1].set_ylabel(r'$y$')
ax[1].set_title('2D ' + r'$%s$' % C)

divider1 = make_axes_locatable(ax[1])
cax1 = divider1.append_axes("right", size="5%", pad=0.05)
cb1 = mpl.colorbar.ColorbarBase(cax1, cmap=cmap, norm=CvNorm, orientation='vertical')
cb1.set_label(r'$%s$' % C, labelpad=20, rotation=270)

if 'SAVE' in os.environ and eval(os.environ['SAVE']):
	fig.savefig(filename('Css') + '.eps') # saving the figure
	print('Figure saved as \'' + filename('Css') + '.eps\'')

if 'SHOW' in os.environ and eval(os.environ['SHOW']):
	plt.show()
