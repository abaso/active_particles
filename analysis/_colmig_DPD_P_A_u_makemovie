#! /bin/bash

if [ "$DATA" == "" ]; then
	echo "No data name provided."
	exit 0
fi

SIM_DIR=${SIMULATION_DIRECTORY-/home/yketa/hoomd/colmig_DPD_P_A}

FRAME_INIT="${INITIAL_FRAME-0}"
FRAME_PER="${FRAME_PERIOD-1}"
FRAME_MAX="${FRAME_MAXIMUM-1000}"

. /home/yketa/exponents.sh # exporting letters expressions and float conversion functions
MOV=u_${DATA}_I$(float_to_letters $FRAME_INIT)_M$(float_to_letters $FRAME_MAX)_P$(float_to_letters $FRAME_PER)

MOV_DIR="${MOVIE_DIRECTORY-${SIM_DIR}/movie/${MOV}}"
rm -r "$MOV_DIR" &> /dev/null; mkdir "$MOV_DIR"; mkdir "${MOV_DIR}/frames"
MOV_NAME="${MOVIE_NAME-${MOV}.mp4}"

DATA_DIR="${DATA_DIRECTORY-${SIM_DIR}/data/${DATA}}"
PAR_FILE="${PARAMETERS_FILE-${DATA_DIR}/param.pickle}"
WRAP_FILE="${WRAPPED_FILE-${DATA_DIR}/trajectory.gsd}"
UNWRAP_FILE="${UNWRAPPED_FILE-${DATA_DIR}/trajectory.dat}"
LOG_FILE="${LOGOUTPUT_FILE-${DATA_DIR}/log-output.log}"

WIDTH="${ARROW_WIDTH-1e-3}"
HEAD_W="${HEAD_WIDTH-3e2}*$WIDTH"
HEAD_L="${HEAD_LENGH-1.5}*$HEAD_W"

FRAME_VER="${FRAME_VERTICAL_SIZE-12}"
FRAME_HOR="${FRAME_HORIZONTAL_SIZE-12}"
FRAME_DEF="${FRAME_DEFINITION-80}"

MOVIE_DIRECTORY="$MOV_DIR" PARAMETERS_FILE="$PAR_FILE" WRAPPED_FILE="$WRAP_FILE" UNWRAPPED_FILE="$UNWRAP_FILE" LOGOUTPUT_FILE="$LOG_FILE" INITIAL_FRAME="$FRAME_INIT" FRAME_PERIOD="$FRAME_PER" FRAME_MAXIMUM="$FRAME_MAX" ARROW_WIDTH="$WIDTH" HEAD_WIDTH="$HEAD_W" HEAD_LENGTH="$HEAD_L" FRAME_VERTICAL_SIZE="$FRAME_VER" FRAME_HORIZONTAL_SIZE="$FRAME_HOR" FRAME_DEFINITION="$FRAME_DEF" /home/yketa/miniconda3/bin/python3.6 << 'EOF'

import matplotlib as mpl
mpl.use('Agg')
import matplotlib.pyplot as plt

import numpy as np

import gsd
import gsd.hoomd
import gsd.pygsd

import pickle

import os
import sys

import math

movie_directory = os.environ['MOVIE_DIRECTORY'] # movie making directory
parameters_file = os.environ['PARAMETERS_FILE'] # parameters pickle file
trajectory_file = os.environ['TRAJECTORY_FILE'] # trajectory gsd file
logoutput_file = os.environ['LOGOUTPUT_FILE'] # log output file
position_file = os.environ['POSITION_FILE'] # position output file (without periodic boundary conditions)

frame_init = int(eval(os.environ['INITIAL_FRAME'])) # initial frame for the calculation of the displacement
frame_period = int(eval(os.environ['FRAME_PERIOD'])) # render one frame every frame_period frames
frame_maximum = int(eval(os.environ['FRAME_MAXIMUM'])) # maximum number of frames

width = float(eval(os.environ['ARROW_WIDTH'])) # width of the arrows
head_width = float(eval(os.environ['HEAD_WIDTH'])) # width of the arrows' head (input in ratio of the width of the arrows)
head_length = float(eval(os.environ['HEAD_LENGTH'])) # width of the arrows' head (input in ratio of the width of the arrows' head)

frame_ver = float(eval(os.environ['FRAME_VERTICAL_SIZE'])) # vertical size of the frames (in inches)
frame_hor = float(eval(os.environ['FRAME_HORIZONTAL_SIZE'])) # horizontal size of the frames (in inches)
frame_def = float(eval(os.environ['FRAME_DEFINITION'])) # definition of images (in dots per inches (dpi))

file = open(parameters_file, 'rb')
N, a, pdi, N_sizes, density, box_size, kT, mu, k, vzero, dr, damp_bro, shear_rate, time_step, N_steps, period_dump, prep_steps = pickle.load(file)
file.close()

data = np.genfromtxt(fname=logoutput_file, skip_header=True)

out_param = open(movie_directory + "/param.txt", "w") # movie parameters output file
bytes = out_param.write("PHYSICAL PARAMETERS\n")
bytes = out_param.write("N=%d\n" % N) # number of particles
bytes = out_param.write("mean radius=%e\n" % a) # mean radius of the particles
bytes = out_param.write("PDI=%e\n" % pdi) # polydispersity index
bytes = out_param.write("density=%e\n" % density) # number density of the particles
bytes = out_param.write("L=%e\n" % box_size) # size of the box
bytes = out_param.write("dotgamma=%e\n" % shear_rate) # shear rate
bytes = out_param.write("kT=%e\n" % kT) # temperature
bytes = out_param.write("mu=%e\n" % mu) # mobility of the particles
bytes = out_param.write("k=%e\n" % k) # spring constant of the harmonic contact repulsion of the particles
bytes = out_param.write("v_0=%e\n" % vzero) # amplitude of the self-propelling force
bytes = out_param.write("D_r=%e\n" % dr) # rotation diffusion constant of the self-propelling force
bytes = out_param.write("damping=%e\n" % damp_bro) # damping for the Brownian dynamics
bytes = out_param.write("PREPARATION PARAMETERS\n")
bytes = out_param.write("FIRE steps=%e\n" % prep_steps) # number of FIRE minimization steps
bytes = out_param.write("INTEGRATION PARAMETERS\n")
bytes = out_param.write("dt=%e\n" % time_step) # integration time step
bytes = out_param.write("steps=%d\n" % N_steps) # number of integration steps
bytes = out_param.write("T_dump=%d\n\n" % period_dump) # period of dumping to gsd file

N_frames = min(frame_maximum, math.ceil((N_steps//period_dump - frame_init)/frame_period)) # number of frames to render

prep_frames = math.ceil(prep_steps/period_dump) # number of preparation frames

pos = t[prep_frames + frame_init].particles.position # position of the particles at initial time
pos0 = np.genfromtxt(fname=position_file, delimiter=',', skip_header=prep_frames + frame_init, max_rows=1)[:-1] # position of the particles at initial time (without periodic boundary conditions)

frame = 0 # number of the frame
with gsd.pygsd.GSDFile(open(wrap_file_name, 'rb')) as wrap_file, open(unwrap_file_name, 'rb') as unwrap_file:
	w_traj = gsd.hoomd.HOOMDTrajectory(wrap_file);
	pos = w_traj[int(prep_frames + frame_init)].particles.position[:, :2] # positions of the particles at the initial frame
	pos0 = getarray(unwrap_file, N, frame_init) # positions at the initial frame

	for time in range(frame_init, int(N_steps//period_dump)): # for every frame
		if (time - frame_init)%frame_period == 0 and frame < N_frames:
			sys.stdout.write("Frame: %d" % (frame + 1) + "/%d \r" % N_frames)

			bytes = out_param.write("FRAME %d" % (frame + 1) + ": t=%e\n" %(time*time_step*period_dump))
			bytes = out_param.write("E_p=%e\n" % data[prep_frames + time, 1])
			bytes = out_param.write("kT=%e\n" % data[prep_frames + time, 2])
			bytes = out_param.write("pxx=%e\n" % data[prep_frames + time, 3])
			bytes = out_param.write("pyy=%e\n" % data[prep_frames + time, 6])
			bytes = out_param.write("pxy=%e\n" % data[prep_frames + time, 4])
			bytes = out_param.write("tilt=%e\n\n" % data[prep_frames + time, 10])

			fig, ax = plt.subplots()
			fig.set_size_inches(frame_hor, frame_ver)

			displacements = getarray(unwrap_file, N, time) - pos0 # displacements between initial and current frame
			disp_n = np.sqrt(np.sum(displacements**2, axis=1)) # norms of the displacements

			for particle in range(N): # for every particle in the frame
				if disp_n[particle] > 0: # draw arrow only if the particles moved
					ax.arrow(pos[particle, 0], pos[particle, 1], displacements[particle, 0], displacements[particle, 1], width=disp_n[particle]*width, head_width=disp_n[particle]*head_width, head_length=disp_n[particle]*head_length, head_starts_at_zero=True, color='blue')

			ax.set_xlim([-1.1*box_size/2, 1.1*box_size/2])
			ax.set_ylim([-1.1*box_size/2, 1.1*box_size/2])
			ax.set_aspect('equal')

			ax.set_xlabel(r'$x$')
			ax.set_ylabel(r'$y$')

			ax.set_title(r'$t=$' + '%e' %(time*time_step*period_dump))

			fig.savefig(movie_directory + '/frames/' + '%010d' % frame, dpi=frame_def)
			plt.close()
			frame += 1

sys.stdout.write("\n")
out_param.close()

EOF

/home/yketa/bin/ffmpeg -r 5 -f image2 -s 1280x960 -i "${MOV_DIR}"/frames/%10d.png -pix_fmt yuv420p "${MOV_DIR}/$MOV_NAME"

