#! /home/yketa/miniconda3/bin/python3.6

import os
import sys

import numpy as np

import pickle

sys.path.append('/home/yketa')
from exponents import float_to_letters

data_dir = os.environ['DATA_DIRECTORY'] if 'DATA_DIRECTORY' in os.environ else os.getcwd() # data directory
parameters_file = os.environ['PARAMETERS_FILE'] if 'PARAMETERS_FILE' in os.environ else data_dir + '/param.pickle' # parameters file

dis_time = int(eval(os.environ['TIME'])) if 'TIME' in os.environ else -1 # time interval for the displacement

init_frame = int(eval(os.environ['INITIAL_FRAME'])) if 'INITIAL_FRAME' in os.environ else -1 # initial time for the calculation of the displacement correlation
int_max = int(eval(os.environ['INTERVAL_MAXIMUM'])) if 'INTERVAL_MAXIMUM' in os.environ else 1 # maximum number of intervals taken for the calculation of the displacement correlation

with open(parameters_file, 'rb') as param_file:
	N, a, pdi, N_sizes, density, box_size, kT, mu, k, vzero, dr, damp_bro, shear_rate, time_step, N_steps, period_dump, prep_steps = pickle.load(param_file)

Ncases = int(eval(os.environ['N_CASES'])) if 'N_CASES' in os.environ else int(np.sqrt(N)) + (1 - int(np.sqrt(N))%2) # number of cases in each direction to compute the velocity grid

Nentries = N_steps//period_dump # number of time snapshots in velocity and position files
init_frame = int(Nentries/2) if init_frame < 0 else init_frame # initial frame
Nframes = Nentries - init_frame # number of frames available for the calculation

dis_time = Nframes + dis_time if dis_time <= 0 else dis_time # length of the interval of time for which the correlation displacement is calculated

correlation = os.environ['CORRELATION'] if 'CORRELATION' in os.environ else 'Cuu'
C = {'Cuu':'C_{uu}', 'Cww':'C_{\delta u \delta u}', 'Cdd':'C_{|u||u|}', 'Cee':'C_{\hat{u}\hat{u}}'}

filename = lambda var: data_dir + '/' + var + ('b' if not('ENDPOINT' in os.environ and eval(os.environ['ENDPOINT'])) else '') + str('_D%s_V%s_R%s_N%s_I%s_T%s_M%s_C%s' % tuple(map(float_to_letters, [density, vzero, dr, N, init_frame, dis_time, int_max, Ncases]))) # filename
C_file_name = os.environ['C_FILE'] if 'C_FILE' in os.environ else filename(correlation) + 'pickle' # C file name
Cnn_file_name = os.environ['CNN_FILE'] if 'CNN_FILE' in os.environ else filename('Cnn') + '.pickle' # Cnn file name

with open(C_file_name, 'rb') as C_file, open(Cnn_file_name, 'rb') as Cnn_file:
	if not('ORIENTATIONAL' in os.environ and not(os.environ['ORIENTATIONAL'])):
		C2D, C1D, C1Dcor, CL, CT = pickle.load(C_file)
	else:
		C2D, C1D, C1Dcor = pickle.load(C_file)
	Cnn2D, Cnn1D = pickle.load(Cnn_file)

# PLOT

import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.colors as colors
import matplotlib.cm as cmx
from mpl_toolkits.axes_grid1 import make_axes_locatable
from matplotlib.gridspec import GridSpec
cmap = plt.cm.jet

# plot parameters

C_min = float(eval(os.environ['C_MIN'])) if 'C_MIN' in os.environ else 1e-3
C_max = float(eval(os.environ['C_MAX'])) if 'C_MAX' in os.environ else 1

r_min = float(eval(os.environ['R_MIN'])) if 'R_MIN' in os.environ else 1
r_max = float(eval(os.environ['R_MAX'])) if 'R_MAX' in os.environ else 20

plot_axis = os.environ['AXIS'] if 'AXIS' in os.environ else 'LOGLOG'
fplot = lambda ax: ax.loglog if plot_axis == 'LOGLOG' else ax.semilogy if plot_axis == 'LINLOG' else ax.semilogx if plot_axis == 'LOGLIN' else ax.plot

fig, axs = plt.subplots(2, 2)

fig.set_size_inches(16, 16)
fig.subplots_adjust(wspace=0.3)
fig.subplots_adjust(hspace=0.3)

fig.suptitle(r'$N=%.2e, \phi=%1.2f, \tilde{v}=%.2e, \tilde{\nu}_r=%.2e$' % (N, density, vzero, dr) + '\n' + r'$S_{init}=%.2e, \Delta t=%.2e, S_{max}=%.2e, N_{cases}=%.2e$' % (init_frame, dis_time*period_dump*time_step, int_max, Ncases))

# Cuu2D

Cmin = np.min(C2D)
Cmax = np.max(C2D)

CvNorm = colors.Normalize(vmin=Cmin, vmax=Cmax)
CscalarMap = cmx.ScalarMappable(norm=CvNorm, cmap=cmap) 

r_max_cases = int(r_max*(box_size/Ncases))
C2D_display = np.roll(np.roll(C2D, int(Ncases/2), axis=0), int(Ncases/2), axis=1)[int(Ncases/2) - r_max_cases:int(Ncases/2) + r_max_cases + 1, int(Ncases/2) - r_max_cases:int(Ncases/2) + r_max_cases + 1]

axs[0, 0].imshow(C2D_display, cmap=cmap, norm=CvNorm, extent=[-r_max, r_max, -r_max, r_max])

axs[0, 0].set_xlabel(r'$x$')
axs[0, 0].set_ylabel(r'$y$')
axs[0, 0].set_title('2D ' + C)

divider = make_axes_locatable(axs[0, 0])
cax = divider.append_axes("right", size="5%", pad=0.05)
cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=CvNorm, orientation='vertical')
cb.set_label(C, labelpad=20, rotation=270)

# Cuu1D shifted

fplot(axs[1, 0])(C1D[1:, 0], C1D[1:, 1]/Cnn1D[-1, 1])

axs[1, 0].set_xlabel(r'$r$')
axs[1, 0].set_ylabel(C + r'$/C_{\rho\rho}(r=r_{max})$')
axs[1, 0].set_title('radial ' + C + r'$/C_{\rho\rho}(r=r_{max})$' + ' ' + r'$(C_{\rho\rho}(r=r_{max}) = %.3e)$' % Cnn1D[-1, 1])

axs[1, 0].set_xlim(r_min, r_max)
axs[1, 0].set_ylim(C_min, C_max)

# Cnn1D and Cuu1D

axs[0, 1].set_title('radial ' + r'$C_{\rho\rho}$' + ' and ' + C)
axs[0, 1].set_xlabel(r'$r$')
axs[0, 1].set_xlim(r_min, r_max)

axs[0, 1].plot(Cnn1D[1:, 0], Cnn1D[1:, 1], color='#1f77b4')
axs[0, 1].set_ylabel(r'$C_{\rho\rho}$', color='#1f77b4')
axs[0, 1].tick_params('y', colors='#1f77b4')

ax_right = axs[0, 1].twinx()
ax_right.semilogy(C1D[1:, 0], C1D[1:, 1], color='#ff7f0e')
ax_right.set_ylabel(C, color='#ff7f0e', rotation=270, labelpad=10)
ax_right.tick_params('y', colors='#ff7f0e')
ax_right.set_ylim(C_min*Cnn1D[-1, 1], C_max*Cnn1D[-1, 1])

# Cuu1D/Cnn

fplot(axs[1, 1])(C1Dcor[1:, 0], C1Dcor[1:, 1])

axs[1, 1].set_xlabel(r'$r$')
axs[1, 1].set_ylabel(C + r'$/C_{\rho\rho}$')
axs[1, 1].set_title('radial ' + C + r'$/C_{\rho\rho}$')

axs[1, 1].set_xlim(r_min, r_max)
axs[1, 1].set_ylim(C_min, C_max)

def plot_correlation(C, C2D, C1D, C1Dcor, C_min, C_max, **directional_correlations):

	fig, axs = plt.subplots(2, 2)

	fig.set_size_inches(16, 16)
	fig.subplots_adjust(wspace=0.3)
	fig.subplots_adjust(hspace=0.3)

	fig.suptitle(r'$N=%.2e, \phi=%1.2f, \tilde{v}=%.2e, \tilde{\nu}_r=%.2e$' % (N, density, vzero, dr) + '\n' + r'$S_{init}=%.2e, \Delta t=%.2e, S_{max}=%.2e, N_{cases}=%.2e$' % (init_frame, dis_time*period_dump*time_step, int_max, Ncases))

	# Cuu2D

	Cmin = np.min(C2D)
	Cmax = np.max(C2D)

	CvNorm = colors.Normalize(vmin=Cmin, vmax=Cmax)
	CscalarMap = cmx.ScalarMappable(norm=CvNorm, cmap=cmap) 

	r_max_cases = int(r_max*(box_size/Ncases))
	C2D_display = np.roll(np.roll(C2D, int(Ncases/2), axis=0), int(Ncases/2), axis=1)[int(Ncases/2) - r_max_cases:int(Ncases/2) + r_max_cases + 1, int(Ncases/2) - r_max_cases:int(Ncases/2) + r_max_cases + 1]

	axs[0, 0].imshow(C2D_display, cmap=cmap, norm=CvNorm, extent=[-r_max, r_max, -r_max, r_max])

	axs[0, 0].set_xlabel(r'$x$')
	axs[0, 0].set_ylabel(r'$y$')
	axs[0, 0].set_title('2D ' + r'$%s$' % C + ' ' + (r'$(%s^T/%s^L(\frac{r}{a} = %.3e) = %.3e)$' % (C, C, (box_size/Ncases)/a, directional_correlations['CT']/directional_correlations['CL']) if 'CL' in directional_correlations and 'CT' in directional_correlations else ''))

	divider = make_axes_locatable(axs[0, 0])
	cax = divider.append_axes("right", size="5%", pad=0.05)
	cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=CvNorm, orientation='vertical')
	cb.set_label(r'$%s$' % C, labelpad=20, rotation=270)

	# Cuu1D shifted

	fplot(axs[1, 0])(C1D[1:, 0], C1D[1:, 1]/Cnn1D[-1, 1])

	axs[1, 0].set_xlabel(r'$r$')
	axs[1, 0].set_ylabel(r'$%s$' % C + r'$/C_{\rho\rho}(r=r_{max})$')
	axs[1, 0].set_title('radial ' + r'$%s$' % C + r'$/C_{\rho\rho}(r=r_{max})$' + ' ' + r'$(C_{\rho\rho}(r=r_{max}) = %.3e)$' % Cnn1D[-1, 1])

	axs[1, 0].set_xlim(r_min, r_max)
	axs[1, 0].set_ylim(C_min, C_max)

	# Cnn1D and Cuu1D

	axs[0, 1].set_title('radial ' + r'$C_{\rho\rho}$' + ' and ' + r'$%s$' % C)
	axs[0, 1].set_xlabel(r'$r$')
	axs[0, 1].set_xlim(r_min, r_max)

	axs[0, 1].plot(Cnn1D[1:, 0], Cnn1D[1:, 1], color='#1f77b4')
	axs[0, 1].set_ylabel(r'$C_{\rho\rho}$', color='#1f77b4')
	axs[0, 1].tick_params('y', colors='#1f77b4')

	ax_right = axs[0, 1].twinx()
	ax_right.semilogy(C1D[1:, 0], C1D[1:, 1], color='#ff7f0e')
	ax_right.set_ylabel(r'$%s$' % C, color='#ff7f0e', rotation=270, labelpad=10)
	ax_right.tick_params('y', colors='#ff7f0e')
	ax_right.set_ylim(C_min*Cnn1D[-1, 1], C_max*Cnn1D[-1, 1])

	# Cuu1D/Cnn

	fplot(axs[1, 1])(C1Dcor[1:, 0], C1Dcor[1:, 1])

	axs[1, 1].set_xlabel(r'$r$')
	axs[1, 1].set_ylabel(r'$%s$' % C + r'$/C_{\rho\rho}$')
	axs[1, 1].set_title('radial ' + r'$%s$' % C + r'$/C_{\rho\rho}$')

	axs[1, 1].set_xlim(r_min, r_max)
	axs[1, 1].set_ylim(C_min, C_max)

	return fig

if not('ORIENTATIONAL' in os.environ and not(os.environ['ORIENTATIONAL'])):
	fig = plot_correlation(C, C2D, C1D, C1Dcor, C_min, C_max, CL=CL, CT=CT)
else:
	fig = plot_correlation(C, C2D, C1D, C1Dcor, C_min, C_max)

if 'SAVE' in os.environ and eval(os.environ['SAVE']):
	fig.savefig(filename('Cuu') + '_' + plot_axis + '.eps') # saving the figure
	print('Figure saved as \'' + filename('Cuu') + '_' + plot_axis + '.eps\'')

if 'SHOW' in os.environ and eval(os.environ['SHOW']):
	plt.show() # showing the figure
