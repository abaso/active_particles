#! /home/yketa/miniconda3/bin/python3.6

import os
import sys

import numpy as np

import pickle

sys.path.append('/home/yketa')
from exponents import float_to_letters

data_dir = os.environ['DATA_DIRECTORY'] if 'DATA_DIRECTORY' in os.environ else os.getcwd() # data directory
parameters_file = os.environ['PARAMETERS_FILE'] if 'PARAMETERS_FILE' in os.environ else data_dir + '/param.pickle' # parameters file

dis_time = int(eval(os.environ['TIME'])) if 'TIME' in os.environ else -1 # time interval for the displacement

init_frame = int(eval(os.environ['INITIAL_FRAME'])) if 'INITIAL_FRAME' in os.environ else -1 # initial time for the calculation of the displacement correlation
int_max = int(eval(os.environ['INTERVAL_MAXIMUM'])) if 'INTERVAL_MAXIMUM' in os.environ else 1 # maximum number of intervals taken for the calculation of the displacement correlation

frame = int(eval(os.environ['FRAME'])) if 'FRAME' in os.environ else 0 # frame to crop in Css dump file
x0 = float(eval(os.environ['X_ZERO'])) if 'X_ZERO' in os.environ else 0 # x coordinate of the centre of the new frame
y0 = float(eval(os.environ['Y_ZERO'])) if 'Y_ZERO' in os.environ else 0 # x coordinate of the centre of the new frame
new_box_size = float(eval(os.environ['BOX_SIZE'])) if 'BOX_SIZE' in os.environ else -1 # new size of the frame box

r_max = float(eval(os.environ['R_MAX'])) if 'R_MAX' in os.environ else 20 # half size of the box showed for 2D correlation

x_min = float(eval(os.environ['X_MIN'])) if 'X_MIN' in os.environ else 4 # minimum radius for C44 plot
x_max = float(eval(os.environ['X_MAX'])) if 'X_MAX' in os.environ else 20 # maximum radius for C44 plot
points_x = int(eval(os.environ['POINTS_THETA'])) if 'POINTS_THETA' in os.environ else 100 # number of points for the radius
points_theta = int(eval(os.environ['POINTS_THETA'])) if 'POINTS_THETA' in os.environ else 100 # number of points for the polar angular coordinate

with open(parameters_file, 'rb') as param_file:
	N, a, pdi, N_sizes, density, box_size, kT, mu, k, vzero, dr, damp_bro, shear_rate, time_step, N_steps, period_dump, prep_steps = pickle.load(param_file)

r_cut = a*float(eval(os.environ['R_CUT'])) if 'R_CUT' in os.environ else a*2 # cutoff radius for coarse graining function
sigma = float(eval(os.environ['SIGMA'])) if 'SIGMA' in os.environ else r_cut # length scale of the spatial extent of the coarse graining function

new_box_size = box_size/2 if new_box_size < 0 else new_box_size

r_max = box_size/2 if r_max < 0 else r_max

Ncases = int(eval(os.environ['N_CASES'])) if 'N_CASES' in os.environ else int(np.sqrt(N)) + (1 - int(np.sqrt(N))%2) # number of cases in each direction to compute the strain and vorticity grid

Nentries = N_steps//period_dump # number of time snapshots in velocity and position files
init_frame = int(Nentries/2) if init_frame < 0 else init_frame # initial frame
Nframes = Nentries - init_frame # number of frames available for the calculation

dis_time = Nframes + dis_time if dis_time <= 0 else dis_time # length of the interval of time for which the correlation displacement is calculated

# DATA

filename = lambda var: data_dir + str('/' + var + ('b' if not('ENDPOINT' in os.environ and eval(os.environ['ENDPOINT'])) else '') + '_D%s_V%s_R%s_N%s_I%s_T%s_M%s_C%s_RCUT%s_SIGM%s' % tuple(map(float_to_letters, [density, vzero, dr, N, init_frame, dis_time, int_max, Ncases, r_cut, sigma]))) # filename
new_filename = lambda var: filename(var) + '_NEWS%s' % float_to_letters(new_box_size)

with open(filename('Css') + '.pickle', 'rb') as Css_dump_file:
	Sgrid = pickle.load(Css_dump_file)[0][frame]

new_box_size_cases = int(new_box_size*(Ncases/box_size)/2)
S2D = np.roll(np.roll(Sgrid, -int(x0*(Ncases/box_size)), axis=0), int(y0*(Ncases/box_size)), axis=1)[int(Ncases/2) - new_box_size_cases:int(Ncases/2) + new_box_size_cases + 1, int(Ncases/2) - new_box_size_cases:int(Ncases/2) + new_box_size_cases + 1] # new strain grid

FFT = np.fft.fft2(S2D)
Corr = np.real(np.fft.ifft2(np.conj(FFT)*FFT))
Corr /= np.sum(S2D**2) # new correlation grid

# PLOT

import matplotlib as mpl
if not('SHOW' in os.environ and eval(os.environ['SHOW'])):
	mpl.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.colors as colors
import matplotlib.cm as cmx
from mpl_toolkits.axes_grid1 import make_axes_locatable
from matplotlib.gridspec import GridSpec
from matplotlib.widgets import Slider
cmap = plt.cm.jet

font_size = int(eval(os.environ['FONT_SIZE'])) if 'FONT_SIZE' in os.environ else 10
mpl.rcParams.update({'font.size': font_size})

wspace = float(eval(os.environ['WSPACE'])) if 'WSPACE' in os.environ else 0.4
hspace = float(eval(os.environ['HSPACE'])) if 'HSPACE' in os.environ else 0.05

fig = plt.figure()
gs = GridSpec(2, 2)
ax0 = plt.subplot(gs[0, 0])
ax1 = plt.subplot(gs[0, 1])
ax2 = plt.subplot(gs[1, :])
var = '\epsilon_{xy}'

fig.set_size_inches(16, 16)
fig.subplots_adjust(wspace=wspace)
fig.subplots_adjust(hspace=hspace)

fig.suptitle(r'$N=%.2e, \phi=%1.2f, \tilde{v}=%.2e, \tilde{\nu}_r=%.2e$' % (N, density, vzero, dr) + '\n' + r'$S_{init}=%.2e, \Delta t=%.2e, S_{max}=%.2e, N_{cases}=%.2e, r_{cut}=%.2e, \sigma=%.2e$' % (init_frame, dis_time*period_dump*time_step, int_max, len(Corr), r_cut, sigma))

# variable map

Smin = -2*np.std(S2D)
Smax = 2*np.std(S2D)

SvNorm = colors.Normalize(vmin=Smin, vmax=Smax)
SscalarMap = cmx.ScalarMappable(norm=SvNorm, cmap=cmap)

ax0.imshow(S2D, cmap=cmap, norm=SvNorm, extent=[x0 - new_box_size/2, x0 + new_box_size/2, y0 - new_box_size/2, y0 + new_box_size/2])

ax0.set_xlabel(r'$x$')
ax0.set_ylabel(r'$y$')
ax0.set_title('2D ' + r'$%s$' % var)

divider0 = make_axes_locatable(ax0)
cax0 = divider0.append_axes("right", size="5%", pad=0.05)
cb0 = mpl.colorbar.ColorbarBase(cax0, cmap=cmap, norm=SvNorm, orientation='vertical')
cb0.set_label(r'$%s$' % var, labelpad=20, rotation=270)

# 2D correlations

C = 'C_{%s%s}' % (var, var)

Cmin = np.min(Corr)
Cmax = np.max(Corr)

CvNorm = colors.Normalize(vmin=Cmin, vmax=Cmax)
CscalarMap = cmx.ScalarMappable(norm=CvNorm, cmap=cmap)

r_max_cases = int(r_max*(len(Corr)/new_box_size))
C2D_display = np.roll(np.roll(Corr, int(len(Corr)/2), axis=0), int(len(Corr)/2), axis=1)[int(len(Corr)/2) - r_max_cases:int(len(Corr)/2) + r_max_cases + 1, int(len(Corr)/2) - r_max_cases:int(len(Corr)/2) + r_max_cases + 1]

ax1.imshow(C2D_display, cmap=cmap, norm=CvNorm, extent=[-r_max, r_max, -r_max, r_max])

ax1.set_xlabel(r'$x$')
ax1.set_ylabel(r'$y$')
ax1.set_title('2D ' + r'$%s$' % C)

divider1 = make_axes_locatable(ax1)
cax1 = divider1.append_axes("right", size="5%", pad=0.05)
cb1 = mpl.colorbar.ColorbarBase(cax1, cmap=cmap, norm=CvNorm, orientation='vertical')
cb1.set_label(r'$%s$' % C, labelpad=20, rotation=270)

# spherical harmonics projection

sep = new_box_size/len(Corr)
def value(r, ang):
    # return Css value at (r, ang) in polar coordinates
    point = r*np.array([np.cos(ang), np.sin(ang)])
    index = (point//sep + len(Corr))%len(Corr)
    return Corr[tuple(list(map(int, index)))]

theta = np.linspace(0, 2*np.pi, points_theta)
integ = lambda r: np.trapz(np.array(list(map(lambda ang: value(r, ang), theta)))*np.cos(4*theta), theta)/np.pi
X = np.linspace(x_min, x_max, points_x)

ax2.set_xlabel(r'$r$')
ax2.set_ylabel(r'$C_4^4(r)$')

ax2.loglog(X, list(map(integ, X)))

if 'SAVE' in os.environ and eval(os.environ['SAVE']):
	fig.savefig(new_filename('Css') + '.eps') # saving the figure
	print('Figure saved as \'' + new_filename('Css') + '.eps\'')
	with open(new_filename('Css') + '.pickle', 'wb') as dump_file:
		pickle.dump([S2D, Corr], dump_file)

# INTERACTIVE PLOT

fig, axs = plt.subplots(1, 2)
fig.set_size_inches(20, 20)
fig.subplots_adjust(wspace=wspace)
fig.subplots_adjust(hspace=hspace)

fig.suptitle(r'$N=%.2e, \phi=%1.2f, \tilde{v}=%.2e, \tilde{\nu}_r=%.2e$' % (N, density, vzero, dr) + '\n' + r'$S_{init}=%.2e, \Delta t=%.2e, S_{max}=%.2e, N_{cases}=%.2e, r_{cut}=%.2e, \sigma=%.2e$' % (init_frame, dis_time*period_dump*time_step, int_max, len(Corr), r_cut, sigma))

# Css

axs[0].imshow(C2D_display, cmap=cmap, norm=CvNorm, extent=[-r_max, r_max, -r_max, r_max])

divider0 = make_axes_locatable(axs[0])
cax0 = divider0.append_axes("right", size="5%", pad=0.05)
cb0 = mpl.colorbar.ColorbarBase(cax0, cmap=cmap, norm=CvNorm, orientation='vertical')
cb0.set_label(r'$C_{\epsilon_{xy}\epsilon_{xy}}$', labelpad=20, rotation=270)

axs[0].set_xlabel(r'$x$')
axs[0].set_ylabel(r'$y$')

circle = plt.Circle([0, 0], r_max/2, color='black', fill=False)
axs[0].add_artist(circle)

# Css(theta)

C = list(map(lambda ang: value(r_max/2, ang), theta))
axs[0].set_title(r'$C^4_4(r = %.3e) = %.3e$' % (r_max/2, np.trapz(np.array(C)*np.cos(4*theta), theta)/np.pi))
l, = axs[1].plot(theta, C, lw=2, color='red')

axs[1].axhline(y=0, linestyle='--', color='black')
axs[1].set_xlabel(r'$\theta$')
axs[1].set_xlim([0, 2*np.pi])
axs[1].set_ylabel(r'$C_{\epsilon_{xy}\epsilon_{xy}}(r, \theta)$')
axs[1].set_ylim([Cmin, Cmax])

# slider

divider1 = make_axes_locatable(axs[1])
cax1 = divider1.append_axes("bottom", size="5%", pad=0.5)
sr = Slider(cax1, r'$r$', 0, r_max, valinit=r_max/2)

def update(val):
    r = sr.val
    C = list(map(lambda ang: value(r, ang), theta))
    l.set_ydata(C)
    circle.set_radius(r)
    axs[0].set_title(r'$C^4_4(r = %.3e) = %.3e$' % (r, np.trapz(np.array(C)*np.cos(4*theta), theta)/np.pi))
    fig.canvas.draw_idle()
sr.on_changed(update)

if 'SHOW' in os.environ and eval(os.environ['SHOW']):
	plt.show()
