#! /bin/bash

if [ "$DATA" == "" ]; then
	echo "No data name provided."
	exit 0
fi

SIM_DIR=${SIMULATION_DIRECTORY-/home/yketa/hoomd/colmig_DPD_P_A}

FRAME_INIT="${INITIAL_FRAME-0}"
FRAME_PER="${FRAME_PERIOD-1}"
FRAME_MAX="${FRAME_MAXIMUM-1000}"

. /home/yketa/exponents.sh # exporting letters expressions and float conversion functions
MOV=${DATA}_I$(float_to_letters $FRAME_INIT)_M$(float_to_letters $FRAME_MAX)_P$(float_to_letters $FRAME_PER)

MOV_DIR="${MOVIE_DIRECTORY-${SIM_DIR}/movie/${MOV}}"
rm -r "$MOV_DIR" &> /dev/null; mkdir "$MOV_DIR"; mkdir "${MOV_DIR}/frames"
MOV_NAME="${MOVIE_NAME-${MOV}.mp4}"

DATA_DIR="${DATA_DIRECTORY-${SIM_DIR}/data/${DATA}}"
PAR_FILE="${PARAMETERS_FILE-${DATA_DIR}/param.pickle}"
WRAP_FILE="${WRAPPED_FILE-${DATA_DIR}/trajectory.gsd}"
UNWRAP_FILE="${UNWRAPPED_FILE-${DATA_DIR}/trajectory.dat}"
LOG_FILE="${LOGOUTPUT_FILE-${DATA_DIR}/log-output.log}"

FRAME_VER="${FRAME_VERTICAL_SIZE-12}"
FRAME_HOR="${FRAME_HORIZONTAL_SIZE-16}"
FRAME_DEF="${FRAME_DEFINITION-80}"

L_MAX="${MAX_BOX_SIZE--1}"

MOVIE_DIRECTORY="$MOV_DIR" PARAMETERS_FILE="$PAR_FILE" WRAPPED_FILE="$WRAP_FILE" UNWRAPPED_FILE="$UNWRAP_FILE" LOGOUTPUT_FILE="$LOG_FILE" INITIAL_FRAME="$FRAME_INIT" FRAME_PERIOD="$FRAME_PER" FRAME_MAXIMUM="$FRAME_MAX" FRAME_VERTICAL_SIZE="$FRAME_VER" FRAME_HORIZONTAL_SIZE="$FRAME_HOR" FRAME_DEFINITION="$FRAME_DEF" MAX_BOX_SIZE="$L_MAX" /home/yketa/miniconda3/bin/python3.6 << 'EOF'

import matplotlib as mpl
mpl.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.colors as colors
import matplotlib.cm as cmx
from mpl_toolkits.axes_grid1 import make_axes_locatable

cmap = plt.cm.jet

import numpy as np

import gsd
import gsd.hoomd
import gsd.pygsd

import pickle

import os
import sys

sys.path.append('/home/yketa/hoomd/colmig_DPD_P_A/data')
from readdat import *

import math

movie_directory = os.environ['MOVIE_DIRECTORY'] # movie making directory

parameters_file = os.environ['PARAMETERS_FILE'] # parameters pickle file
wrap_file_name = os.environ['WRAPPED_FILE'] # trajectory gsd file
unwrap_file_name = os.environ['UNWRAPPED_FILE'] # trajectory binary file
logoutput_file = os.environ['LOGOUTPUT_FILE'] # log output file

frame_init = int(eval(os.environ['INITIAL_FRAME'])) # initial frame of the movie
frame_period = int(eval(os.environ['FRAME_PERIOD'])) # render one frame every frame_period frames
frame_maximum = int(eval(os.environ['FRAME_MAXIMUM'])) # maximum number of frames

frame_ver = float(eval(os.environ['FRAME_VERTICAL_SIZE'])) # vertical size of the frames (in inches)
frame_hor = float(eval(os.environ['FRAME_HORIZONTAL_SIZE'])) # horizontal size of the frames (in inches)
frame_def = float(eval(os.environ['FRAME_DEFINITION'])) # definition of images (in dots per inches (dpi))

with open(parameters_file, 'rb') as param_file:
	N, a, pdi, N_sizes, density, box_size, kT, mu, k, vzero, dr, damp_bro, shear_rate, time_step, N_steps, period_dump, prep_steps = pickle.load(param_file)

max_box_size = box_size if float(eval(os.environ['MAX_BOX_SIZE'])) < 0 else float(eval(os.environ['MAX_BOX_SIZE'])) # maximum size of the box rendered in the movie

data = np.genfromtxt(fname=logoutput_file, skip_header=True)

out_param = open(movie_directory + "/param.txt", "w") # movie parameters output file
bytes = out_param.write("PHYSICAL PARAMETERS\n")
bytes = out_param.write("N=%d\n" % N) # number of particles
bytes = out_param.write("mean radius=%e\n" % a) # mean radius of the particles
bytes = out_param.write("PDI=%e\n" % pdi) # polydispersity index
bytes = out_param.write("density=%e\n" % density) # number density of the particles
bytes = out_param.write("L=%e\n" % box_size) # size of the box
bytes = out_param.write("dotgamma=%e\n" % shear_rate) # shear rate
bytes = out_param.write("kT=%e\n" % kT) # temperature
bytes = out_param.write("mu=%e\n" % mu) # mobility of the particles
bytes = out_param.write("k=%e\n" % k) # spring constant of the harmonic contact repulsion of the particles
bytes = out_param.write("v_0=%e\n" % vzero) # amplitude of the self-propelling force
bytes = out_param.write("D_r=%e\n" % dr) # rotation diffusion constant of the self-propelling force
bytes = out_param.write("damping=%e\n" % damp_bro) # damping for the Brownian dynamics
bytes = out_param.write("PREPARATION PARAMETERS\n")
bytes = out_param.write("FIRE steps=%e\n" % prep_steps) # number of FIRE minimization steps
bytes = out_param.write("INTEGRATION PARAMETERS\n")
bytes = out_param.write("dt=%e\n" % time_step) # integration time step
bytes = out_param.write("steps=%d\n" % N_steps) # number of integration steps
bytes = out_param.write("T_dump=%d\n\n" % period_dump) # period of dumping to gsd file

N_frames = min(frame_maximum, math.ceil((N_steps//period_dump - frame_init)/frame_period)) # number of frames to render

vmin = np.log(vzero/100)
vmax = np.log(2*vzero)
np.seterr(divide=None)

prep_frames = prep_steps//period_dump # number of preparation frames

frame = 0 # number of the frame
with gsd.pygsd.GSDFile(open(wrap_file_name, 'rb')) as wrap_file, open(unwrap_file_name, 'rb') as unwrap_file:
	w_traj = gsd.hoomd.HOOMDTrajectory(wrap_file);

	for time in range(frame_init, int(N_steps//period_dump)): # for every frame
		if (time - frame_init)%frame_period == 0 and frame < N_frames:
			sys.stdout.write("Frame: %d" % (frame + 1) + "/%d \r" % N_frames)

			bytes = out_param.write("FRAME %d" % (frame + 1) + ": t=%e\n" %(time*time_step*period_dump))
			bytes = out_param.write("E_p=%e\n" % data[prep_frames + time, 1])
			bytes = out_param.write("kT=%e\n" % data[prep_frames + time, 2])
			bytes = out_param.write("pxx=%e\n" % data[prep_frames + time, 3])
			bytes = out_param.write("pyy=%e\n" % data[prep_frames + time, 6])
			bytes = out_param.write("pxy=%e\n" % data[prep_frames + time, 4])
			bytes = out_param.write("tilt=%e\n\n" % data[prep_frames + time, 10])

			fig, ax = plt.subplots()
			fig.set_size_inches(frame_hor, frame_ver)

			vNorm = colors.Normalize(vmin=vmin, vmax=vmax)
			scalarMap = cmx.ScalarMappable(norm=vNorm, cmap=cmap)

			positions = w_traj[int(prep_frames + time)].particles.position[:, :2] # positions of the particles (with periodic boundary conditions)
			velocities = getarray(unwrap_file, N, time, variable='velocity') # velocities of the particles

			for particle in range(N): # for every particle in the frame

				if (np.abs(positions[particle]) <= max_box_size/2).all():
					n_vel = np.sqrt(np.sum(velocities[particle]**2)) # norm of the velocity of particle particle
					u_vel = velocities[particle]/n_vel if n_vel > 0 else np.zeros(2) # unitary velocity direction

					circle = plt.Circle(tuple((positions[particle] + box_size/2)%box_size - box_size/2), w_traj[0].particles.diameter[particle]/2, color=scalarMap.to_rgba(np.log(n_vel)), fill=True)
					ax.add_artist(circle)

					ax.arrow(positions[particle, 0], positions[particle, 1], w_traj[0].particles.diameter[particle]*u_vel[0], w_traj[0].particles.diameter[particle]*u_vel[1], color='black')

			divider = make_axes_locatable(ax)
			cax = divider.append_axes("right", size="5%", pad=0.05)

			cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=vNorm, orientation='vertical')

			ax.set_xlim([-1.1*max_box_size/2, 1.1*max_box_size/2])
			ax.set_ylim([-1.1*max_box_size/2, 1.1*max_box_size/2])
			ax.set_aspect('equal')

			ax.set_xlabel(r'$x$')
			ax.set_ylabel(r'$y$')

			ax.set_title(r'$t=$' + '%e' %(time*time_step*period_dump))

			fig.savefig(movie_directory + '/frames/' + '%010d' % frame, dpi=frame_def)
			plt.close()
			frame += 1

sys.stdout.write("\n")
out_param.close()

EOF

/home/yketa/bin/ffmpeg -r 5 -f image2 -s 1280x960 -i "${MOV_DIR}"/frames/%10d.png -pix_fmt yuv420p "${MOV_DIR}/$MOV_NAME"

