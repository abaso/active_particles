#! /bin/bash

if [ "$DATA" == "" ]; then
	echo "No data name provided."
	exit 0
fi

SIM_DIR=${SIMULATION_DIRECTORY-/home/yketa/hoomd/colmig_DPD_P_A}

MOV_DIR="${MOVIE_DIRECTORY-${SIM_DIR}/movie/${DATA}}"
rm -r "$MOV_DIR" &> /dev/null; mkdir "$MOV_DIR"; mkdir "${MOV_DIR}/frames"

MOV_NAME="${MOVIE_NAME-${DATA}.mp4}"

DATA_DIR="${DATA_DIRECTORY-${SIM_DIR}/data/${DATA}}"
PAR_FILE="${PARAMETERS_FILE-${DATA_DIR}/param.pickle}"
TRAJ_FILE="${TRAJECTORY_FILE-${DATA_DIR}/trajectory.gsd}"
LOG_FILE="${LOGOUTPUT_FILE-${DATA_DIR}/log-output.log}"
VEL_FILE="${VELOCITY_FILE-${DATA_DIR}/velocity.csv}"

FRAME_PER="${FRAME_PERIOD-1}"
FRAME_MAX="${FRAME_MAXIMUM-1000}"

FRAME_VER="${FRAME_VERTICAL_SIZE-12}"
FRAME_HOR="${FRAME_HORIZONTAL_SIZE-16}"
FRAME_DEF="${FRAME_DEFINITION-80}"

MOVIE_DIRECTORY="$MOV_DIR" PARAMETERS_FILE="$PAR_FILE" TRAJECTORY_FILE="$TRAJ_FILE" LOGOUTPUT_FILE="$LOG_FILE" VELOCITY_FILE="$VEL_FILE" FRAME_PERIOD="$FRAME_PER" FRAME_MAXIMUM="$FRAME_MAX" FRAME_VERTICAL_SIZE="$FRAME_VER" FRAME_HORIZONTAL_SIZE="$FRAME_HOR" FRAME_DEFINITION="$FRAME_DEF" /home/yketa/miniconda3/bin/python3.6 << 'EOF'

import matplotlib as mpl
mpl.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.colors as colors
import matplotlib.cm as cmx
from mpl_toolkits.axes_grid1 import make_axes_locatable

cmap = plt.cm.jet

import numpy as np

import gsd
import gsd.hoomd
import gsd.pygsd

import pickle

import os
import sys

movie_directory = os.environ['MOVIE_DIRECTORY'] # movie making directory
parameters_file = os.environ['PARAMETERS_FILE'] # parameters pickle file
trajectory_file = os.environ['TRAJECTORY_FILE'] # trajectory gsd file
logoutput_file = os.environ['LOGOUTPUT_FILE'] # log output file
velocity_file = os.environ['VELOCITY_FILE'] # velocity output file

frame_period = int(eval(os.environ['FRAME_PERIOD'])) # render one frame every frame_period frames
frame_maximum = int(eval(os.environ['FRAME_MAXIMUM'])) # maximum number of frames

frame_ver = float(eval(os.environ['FRAME_VERTICAL_SIZE'])) # vertical size of the frames (in inches)
frame_hor = float(eval(os.environ['FRAME_HORIZONTAL_SIZE'])) # horizontal size of the frames (in inches)
frame_def = float(eval(os.environ['FRAME_DEFINITION'])) # definition of images (in dots per inches (dpi))

file = open(parameters_file, 'rb')
N, a, pdi, N_sizes, density, box_size, kT, mu, k, vzero, dr, damp_bro, shear_rate, time_step, N_steps, period_dump, prep_steps = pickle.load(file)
file.close()

f = gsd.pygsd.GSDFile(open(trajectory_file, 'rb'));
t = gsd.hoomd.HOOMDTrajectory(f);

data = np.genfromtxt(fname=logoutput_file, skip_header=True)
data_vel = np.genfromtxt(fname=velocity_file, delimiter=',')

out_param = open(movie_directory + "/param.txt", "w") # movie parameters output file
bytes = out_param.write("PHYSICAL PARAMETERS\n")
bytes = out_param.write("N=%d\n" % N) # number of particles
bytes = out_param.write("mean radius=%e\n" % a) # mean radius of the particles
bytes = out_param.write("PDI=%e\n" % pdi) # polydispersity index
bytes = out_param.write("density=%e\n" % density) # number density of the particles
bytes = out_param.write("L=%e\n" % box_size) # size of the box
bytes = out_param.write("dotgamma=%e\n" % shear_rate) # shear rate
bytes = out_param.write("kT=%e\n" % kT) # temperature
bytes = out_param.write("mu=%e\n" % mu) # mobility of the particles
bytes = out_param.write("k=%e\n" % k) # spring constant of the harmonic contact repulsion of the particles
bytes = out_param.write("v_0=%e\n" % vzero) # amplitude of the self-propelling force
bytes = out_param.write("D_r=%e\n" % dr) # rotation diffusion constant of the self-propelling force
bytes = out_param.write("damping=%e\n" % damp_bro) # damping for the Brownian dynamics
bytes = out_param.write("PREPARATION PARAMETERS\n")
bytes = out_param.write("FIRE steps=%e\n" % prep_steps) # number of FIRE minimization steps
bytes = out_param.write("INTEGRATION PARAMETERS\n")
bytes = out_param.write("dt=%e\n" % time_step) # integration time step
bytes = out_param.write("steps=%d\n" % N_steps) # number of integration steps
bytes = out_param.write("T_dump=%d\n" % period_dump) # period of dumping to gsd file

N_frames = min(frame_maximum, len(data_vel)//frame_period if len(data_vel)%frame_period == 0 else len(data_vel)//frame_period + 1) # number of frames to render

vmin = 0
vmax = 3*vzero

prep_frames = prep_steps//period_dump # number of preparation frames

frame = 0 # number of the frame
for time in range(len(data_vel)): # for every frame
	if time%frame_period == 0 and frame < N_frames:
		sys.stdout.write("Frame: %d" % (frame + 1) + "/%d \r" % N_frames)

		bytes = out_param.write("FRAME %d" % (frame + 1) + ": t=%e" %(time*time_step*period_dump))
		bytes = out_param.write("E_p=%e\n" % data[prep_frames + time, 1])
		bytes = out_param.write("kT=%e\n" % data[prep_frames + time, 2])
		bytes = out_param.write("pxx=%e\n" % data[prep_frames + time, 3])
		bytes = out_param.write("pyy=%e\n" % data[prep_frames + time, 6])
		bytes = out_param.write("pxy=%e\n" % data[prep_frames + time, 4])
		bytes = out_param.write("tilt=%e\n\n" % data[prep_frames + time, 10])

		fig, ax = plt.subplots()
		fig.set_size_inches(frame_hor, frame_ver)

		vNorm = colors.Normalize(vmin=vmin, vmax=vmax)
		scalarMap = cmx.ScalarMappable(norm=vNorm, cmap=cmap)

		for particle in range(N): # for every particle in the frame

			position = data_vel[time, particle*3:particle*3 + 2] # position of the particle
			velocity = data_vel[time, N*3 + particle*3:N*3 + particle*3 + 2]/np.sqrt(np.sum(data_vel[time, N*3 + particle*3:N*3 + particle*3 + 2]**2)) if np.sqrt(np.sum(data_vel[time, N*3 + particle*3:N*3 + particle*3 + 2]**2)) != 0 else np.array([0, 0]) # normalised velocity of the particle

			circle = plt.Circle(tuple((position + box_size/2)%box_size - box_size/2), t[0].particles.diameter[particle]/2, color='blue', fill=False)
			ax.add_artist(circle)

			ax.arrow(position[0], position[1], t[0].particles.diameter[particle]*velocity[0], t[0].particles.diameter[particle]*velocity[1], color=scalarMap.to_rgba(np.sqrt(np.sum(data_vel[time, N*3 + particle*3:N*3 + particle*3 + 2]**2))))

		divider = make_axes_locatable(ax)
		cax = divider.append_axes("right", size="5%", pad=0.05)

		cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=vNorm, orientation='vertical')

		ax.set_xlim([-1.1*box_size/2, 1.1*box_size/2])
		ax.set_ylim([-1.1*box_size/2, 1.1*box_size/2])
		ax.set_aspect('equal')

		ax.set_xlabel('x')
		ax.set_ylabel('y')

		ax.set_title('t=%e' %(time*time_step*period_dump))

		fig.savefig(movie_directory + '/frames/' + '%010d' % frame, dpi=frame_def)
		plt.close()
		frame += 1

sys.stdout.write("\n")
out_param.close()

EOF

/home/yketa/bin/ffmpeg -r 5 -f image2 -s 1280x960 -i "${MOV_DIR}"/frames/%10d.png -pix_fmt yuv420p "${MOV_DIR}/$MOV_NAME"

