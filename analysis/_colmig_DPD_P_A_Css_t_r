#! /home/yketa/miniconda3/bin/python3.6

import os
import sys

import numpy as np

import pickle

sys.path.append('/home/yketa')
from exponents import float_to_letters

data_dir = os.environ['DATA_DIRECTORY'] if 'DATA_DIRECTORY' in os.environ else os.getcwd() # data directory
parameters_file = os.environ['PARAMETERS_FILE'] if 'PARAMETERS_FILE' in os.environ else data_dir + '/param.pickle' # parameters file

dis_time = int(eval(os.environ['TIME'])) if 'TIME' in os.environ else -1 # time interval for the displacement

init_frame = int(eval(os.environ['INITIAL_FRAME'])) if 'INITIAL_FRAME' in os.environ else -1 # initial time for the calculation of the displacement correlation
int_max = int(eval(os.environ['INTERVAL_MAXIMUM'])) if 'INTERVAL_MAXIMUM' in os.environ else 1 # maximum number of intervals taken for the calculation of the displacement correlation

r_max = float(eval(os.environ['R_MAX'])) if 'R_MAX' in os.environ else 20 # half size of the box showed for 2D correlation

points_theta = int(eval(os.environ['POINTS_THETA'])) if 'POINTS_THETA' in os.environ else 100 # number of points for the polar angular coordinate

with open(parameters_file, 'rb') as param_file:
	N, a, pdi, N_sizes, density, box_size, kT, mu, k, vzero, dr, damp_bro, shear_rate, time_step, N_steps, period_dump, prep_steps = pickle.load(param_file)

r_cut = a*float(eval(os.environ['R_CUT'])) if 'R_CUT' in os.environ else a*2 # cutoff radius for coarse graining function
sigma = float(eval(os.environ['SIGMA'])) if 'SIGMA' in os.environ else r_cut # length scale of the spatial extent of the coarse graining function

r_max = box_size/2 if r_max < 0 else r_max

Ncases = int(eval(os.environ['N_CASES'])) if 'N_CASES' in os.environ else int(np.sqrt(N)) + (1 - int(np.sqrt(N))%2) # number of cases in each direction to compute the strain and vorticity grid

Nentries = N_steps//period_dump # number of time snapshots in velocity and position files
init_frame = int(Nentries/2) if init_frame < 0 else init_frame # initial frame
Nframes = Nentries - init_frame # number of frames available for the calculation

dis_time = Nframes + dis_time if dis_time <= 0 else dis_time # length of the interval of time for which the correlation displacement is calculated

# DATA

filename = lambda var: data_dir + str('/' + var + ('b' if not('ENDPOINT' in os.environ and eval(os.environ['ENDPOINT'])) else '') + '_D%s_V%s_R%s_N%s_I%s_T%s_M%s_C%s_RCUT%s_SIGM%s' % tuple(map(float_to_letters, [density, vzero, dr, N, init_frame, dis_time, int_max, Ncases, r_cut, sigma]))) # filename

with open((filename('Css') + '.pickle') if not('FILENAME' in os.environ) else os.environ['FILENAME'], 'rb') as Css_dump_file:
	Css2D = pickle.load(Css_dump_file)[1]

# PLOT

import matplotlib.pyplot as plt
from matplotlib.widgets import Slider
from mpl_toolkits.axes_grid1 import make_axes_locatable
import matplotlib.colors as colors
import matplotlib.cm as cmx
import matplotlib as mpl
cmap = plt.cm.jet

class AdjustablePlot: # adjustable circle
	def __init__(self, circle, radius, line, slider):
		self.circle = circle
		self.radius = radius # radius of the circle
		self.line = line
		self.slider = slider # slider which also adjusts radius
		self.cid = line.figure.canvas.mpl_connect('button_press_event', self)
	def __call__(self, event):
		if event.inaxes!=self.circle.axes: return
		self.radius = np.sqrt(event.xdata**2 + event.ydata**2)
		self.slider.set_val(self.radius)
		self.draw()
	def draw(self):
		# circle
		self.circle.set_radius(self.radius) # adjusting circle radius
		self.circle.figure.canvas.draw()
		# line
		C = list(map(lambda ang: value(self.radius, ang), theta))
		self.line.set_ydata(C)
		self.line.figure.canvas.draw()
		# C44
		axs[0].set_title(r'$C^4_4(r = %.3e) = %.3e$' % (self.radius, np.trapz(np.array(C)*np.cos(4*theta), theta)/np.pi))

font_size = int(eval(os.environ['FONT_SIZE'])) if 'FONT_SIZE' in os.environ else 10
mpl.rcParams.update({'font.size': font_size})

wspace = float(eval(os.environ['WSPACE'])) if 'WSPACE' in os.environ else 0.4
hspace = float(eval(os.environ['HSPACE'])) if 'HSPACE' in os.environ else 0.05

sep = box_size/Ncases
def value(r, ang):
    # return Css value at (r, ang) in polar coordinates
    point = r*np.array([np.cos(ang), np.sin(ang)])
    index = (point//sep + Ncases)%Ncases
    return Css2D[tuple(list(map(int, index)))]

fig, axs = plt.subplots(1, 2)
fig.set_size_inches(20, 20)
fig.subplots_adjust(wspace=wspace)
fig.subplots_adjust(hspace=hspace)

fig.suptitle(r'$N=%.2e, \phi=%1.2f, \tilde{v}=%.2e, \tilde{\nu}_r=%.2e$' % (N, density, vzero, dr) + '\n' + r'$S_{init}=%.2e, \Delta t=%.2e, S_{max}=%.2e, N_{cases}=%.2e, r_{cut}=%.2e, \sigma=%.2e$' % (init_frame, dis_time*period_dump*time_step, int_max, Ncases, r_cut, sigma))

# Css

Cmin = np.min(Css2D)
Cmax = np.max(Css2D)

CvNorm = colors.Normalize(vmin=Cmin, vmax=Cmax)
CscalarMap = cmx.ScalarMappable(norm=CvNorm, cmap=cmap)

r_max_cases = int(r_max*(Ncases/box_size))
C2D_display = np.roll(np.roll(Css2D, int(Ncases/2), axis=0), int(Ncases/2), axis=1)[int(Ncases/2) - r_max_cases:int(Ncases/2) + r_max_cases + 1, int(Ncases/2) - r_max_cases:int(Ncases/2) + r_max_cases + 1]

axs[0].imshow(C2D_display, cmap=cmap, norm=CvNorm, extent=[-r_max, r_max, -r_max, r_max])

divider0 = make_axes_locatable(axs[0])
cax0 = divider0.append_axes("right", size="5%", pad=0.05)
cb0 = mpl.colorbar.ColorbarBase(cax0, cmap=cmap, norm=CvNorm, orientation='vertical')
cb0.set_label(r'$C_{\epsilon_{xy}\epsilon_{xy}}$', labelpad=20, rotation=270)

axs[0].set_xlabel(r'$x$')
axs[0].set_ylabel(r'$y$')

circle = plt.Circle([0, 0], r_max/2, color='black', fill=False)
axs[0].add_artist(circle)

# Css(theta)

theta = np.linspace(0, 2*np.pi, points_theta)
C = list(map(lambda ang: value(r_max/2, ang), theta))
axs[0].set_title(r'$C^4_4(r = %.3e) = %.3e$' % (r_max/2, np.trapz(np.array(C)*np.cos(4*theta), theta)/np.pi))
l, = axs[1].plot(theta, C, lw=2, color='red')

axs[1].axhline(y=0, linestyle='--', color='black')
axs[1].set_xlabel(r'$\theta$')
axs[1].set_xlim([0, 2*np.pi])
axs[1].set_ylabel(r'$C_{\epsilon_{xy}\epsilon_{xy}}(r, \theta)$')
axs[1].set_ylim([Cmin, Cmax])

# slider

divider1 = make_axes_locatable(axs[1])
cax1 = divider1.append_axes("bottom", size="5%", pad=0.5)
sr = Slider(cax1, r'$r$', 0, r_max, valinit=r_max/2)

plots = AdjustablePlot(circle, circle.get_radius(), l, sr)

def update(val):
    plots.radius = sr.val
    plots.draw()
sr.on_changed(update)

plt.show()
